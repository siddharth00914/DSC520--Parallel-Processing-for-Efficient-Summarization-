# -*- coding: utf-8 -*-
"""HPSC_Final code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QjIrpr8eGfCPTXIySPZk-m-D7U3DdH-a
"""

import time
import concurrent.futures
from transformers import pipeline
import matplotlib.pyplot as plt
import numpy as np

# Example text to be summarized
example_text = """
In the heart of a bustling city, a small, quaint café sat nestled between towering skyscrapers. Its warm, inviting glow was a beacon to the weary travelers and bustling locals alike. Inside, the aroma of freshly brewed coffee mingled with the sweet scent of baked goods, creating an atmosphere of comfort and familiarity. The café's walls were adorned with a collection of eclectic artwork, each piece telling its own unique story. Patrons, a diverse mix of artists, students, and business professionals.
"""

# Set up the summarization pipeline
summarizer_model = pipeline("summarization", model="sshleifer/distilbart-cnn-12-6")

# Function to summarize a given text
def summarize(text):
    words = text.split()
    summary = summarizer_model(text, max_length=min(130, len(words) // 2), min_length=max(30, len(words) // 4), do_sample=False)
    return summary[0]['summary_text']

# Function to measure summarization time
def measure_time(text, use_parallel=False, workers=None):
    start = time.time()

    if use_parallel:
        with concurrent.futures.ThreadPoolExecutor(max_workers=workers) as executor:
            result = list(executor.map(summarize, [text]))[0]
    else:
        result = summarize(text)

    end = time.time()
    return end - start

# Serial and Parallel execution timing
time_serial = measure_time(example_text)
time_parallel = measure_time(example_text, use_parallel=True, workers=2)

# Calculate efficiency
efficiency_gain = ((time_serial - time_parallel) / time_serial) * 100

# Display results
print(f"Serial Execution Time(seconds): {time_serial}")
print(f"Parallel Execution Time(seconds): {time_parallel}")
print(f"Efficiency Improvement(seconds): {efficiency_gain}%")

# Plotting comparison
plt.figure(figsize=(8, 4))
plt.bar(["Serial", "Parallel"], [time_serial, time_parallel], color=['blue', 'red'], alpha=0.6)
plt.ylabel('Time (seconds)')
plt.title('Comparison of Serial vs Parallel Execution Time')
plt.show()

# Experiment with different number of cores
core_counts = [1, 2, 3, 4, 5]
times_serial = [measure_time(example_text) for _ in core_counts]
times_parallel = [measure_time(example_text, use_parallel=True, workers=core) for core in core_counts]

# Plotting the impact of different core counts
plt.figure(figsize=(10, 5))
plt.plot(core_counts, times_serial, label='Serial', marker='o', color='blue')
plt.plot(core_counts, times_parallel, label='Parallel', marker='o', color='green')
plt.xlabel('Number of Cores')
plt.ylabel('Time (seconds)')
plt.title('Impact of Core Count on Execution Time')
plt.legend()
plt.grid(True)
plt.show()